# Init Job — Helm post-install hook для инициализации тестовых данных.
# Загружает файлы в SE, переводит se-ro и se-ar в нужные режимы.
# Скрипты lib.sh и init-data.sh — Phase 6.3.
{{- if .Values.initJob.enabled }}
---
# ConfigMap с общей библиотекой функций (lib.sh)
apiVersion: v1
kind: ConfigMap
metadata:
  name: se-test-init-lib
  namespace: {{ .Values.namespace }}
  labels:
    {{- include "se-test.labels" . | nindent 4 }}
  annotations:
    helm.sh/hook: post-install
    helm.sh/hook-weight: "-10"
    helm.sh/hook-delete-policy: before-hook-creation
data:
  # Общая библиотека функций для init и тестовых скриптов.
  # Исходник: tests/scripts/lib.sh
  lib.sh: |
    #!/usr/bin/env bash
    # ==========================================================================
    # lib.sh — общая библиотека функций для SE тестовых скриптов
    # ==========================================================================
    set -euo pipefail

    # Опции curl по умолчанию (self-signed TLS, тихий режим, таймаут)
    : "${CURL_OPTS:=-k -s --connect-timeout 5}"

    # ---- Логирование (цветной вывод) ----

    log_info() { echo -e "\033[0;34m[INFO]\033[0m  $*"; }
    log_ok()   { echo -e "\033[0;32m[OK]\033[0m    $*"; }
    log_fail() { echo -e "\033[0;31m[FAIL]\033[0m  $*"; }
    log_warn() { echo -e "\033[0;33m[WARN]\033[0m  $*"; }

    # ---- Счётчики тестов ----

    PASS_COUNT=0
    FAIL_COUNT=0

    test_pass() {
        ((PASS_COUNT++))
        log_ok "PASS: $*"
    }

    test_fail() {
        ((FAIL_COUNT++))
        log_fail "FAIL: $*"
    }

    print_summary() {
        local total=$((PASS_COUNT + FAIL_COUNT))
        echo ""
        log_info "========================================================"
        log_info "Результаты: ${PASS_COUNT} PASS / ${FAIL_COUNT} FAIL (всего ${total})"
        log_info "========================================================"
        if [[ $FAIL_COUNT -gt 0 ]]; then
            return 1
        fi
        return 0
    }

    # ---- Утилиты для работы с ответами ----
    # Формат ответа: "<http_code> <response_body>"

    get_response_code() { echo "$1" | awk '{print $1}'; }
    get_response_body() { echo "$1" | cut -d' ' -f2-; }

    # ---- Основные функции ----

    # get_token — получить JWT от JWKS Mock
    # Аргументы: $1=mock_url, $2=sub, $3=scopes(JSON), $4=ttl
    # Возвращает: JWT токен через stdout
    get_token() {
        local mock_url="$1"
        local sub="$2"
        local scopes="$3"
        local ttl="${4:-3600}"

        local request_body
        request_body=$(jq -n \
            --arg sub "$sub" \
            --argjson scopes "$scopes" \
            --argjson ttl "$ttl" \
            '{sub: $sub, scopes: $scopes, ttl_seconds: $ttl}')

        local tmpout
        tmpout=$(mktemp)
        local http_code
        http_code=$(curl $CURL_OPTS -w "%{http_code}" -o "$tmpout" \
            -X POST \
            -H "Content-Type: application/json" \
            -d "$request_body" \
            "${mock_url}/token") || true

        local body
        body=$(cat "$tmpout")
        rm -f "$tmpout"

        if [[ "$http_code" != "200" ]]; then
            log_fail "get_token: HTTP ${http_code} от ${mock_url}/token"
            echo ""
            return 1
        fi

        echo "$body" | jq -r '.token'
    }

    # wait_ready — дождаться готовности сервиса (GET /health/ready → 200)
    # Аргументы: $1=url, $2=timeout(секунды)
    wait_ready() {
        local url="$1"
        local timeout="${2:-120}"
        local elapsed=0
        local interval=2

        while [[ $elapsed -lt $timeout ]]; do
            local http_code
            http_code=$(curl $CURL_OPTS -o /dev/null -w "%{http_code}" \
                "${url}/health/ready" 2>/dev/null) || http_code="000"

            if [[ "$http_code" == "200" ]]; then
                return 0
            fi

            sleep $interval
            elapsed=$((elapsed + interval))
        done

        return 1
    }

    # upload_file — загрузить файл в SE (multipart/form-data)
    # Аргументы: $1=se_url, $2=token, $3=filename, $4=content_type, $5=description, $6=file_path
    # Если $6 не указан — генерирует случайный файл ~1KB
    # Возвращает: "<http_code> <response_body>"
    upload_file() {
        local se_url="$1"
        local token="$2"
        local filename="$3"
        local content_type="${4:-application/octet-stream}"
        local description="${5:-}"
        local file_path="${6:-}"

        local tmp_generated=""
        if [[ -z "$file_path" ]]; then
            file_path=$(mktemp)
            dd if=/dev/urandom bs=1024 count=1 2>/dev/null > "$file_path"
            tmp_generated="$file_path"
        fi

        local tmpout
        tmpout=$(mktemp)
        local http_code

        local curl_args=($CURL_OPTS -w "%{http_code}" -o "$tmpout"
            -X POST
            -H "Authorization: Bearer ${token}"
            -F "file=@${file_path};filename=${filename};type=${content_type}")

        if [[ -n "$description" ]]; then
            curl_args+=(-F "description=${description}")
        fi

        http_code=$(curl "${curl_args[@]}" "${se_url}/api/v1/files/upload") || http_code="000"

        local body
        body=$(cat "$tmpout")
        rm -f "$tmpout"
        [[ -n "$tmp_generated" ]] && rm -f "$tmp_generated"

        echo "${http_code} ${body}"
    }

    # transition_mode — сменить режим SE
    # Аргументы: $1=se_url, $2=token, $3=target_mode, $4=confirm(true/false)
    # Возвращает: "<http_code> <response_body>"
    transition_mode() {
        local se_url="$1"
        local token="$2"
        local target_mode="$3"
        local confirm="${4:-false}"

        local request_body
        request_body=$(jq -n \
            --arg mode "$target_mode" \
            --argjson confirm "$confirm" \
            '{target_mode: $mode, confirm: $confirm}')

        local tmpout
        tmpout=$(mktemp)
        local http_code
        http_code=$(curl $CURL_OPTS -w "%{http_code}" -o "$tmpout" \
            -X POST \
            -H "Authorization: Bearer ${token}" \
            -H "Content-Type: application/json" \
            -d "$request_body" \
            "${se_url}/api/v1/mode/transition") || http_code="000"

        local body
        body=$(cat "$tmpout")
        rm -f "$tmpout"

        echo "${http_code} ${body}"
    }

    # assert_status — проверить HTTP статус ответа
    # Аргументы: $1=response, $2=expected_code, $3=message
    assert_status() {
        local response="$1"
        local expected="$2"
        local message="${3:-}"

        local actual
        actual=$(get_response_code "$response")

        if [[ "$actual" == "$expected" ]]; then
            return 0
        else
            if [[ -n "$message" ]]; then
                log_fail "${message}: ожидался HTTP ${expected}, получен ${actual}"
            fi
            local body
            body=$(get_response_body "$response")
            if [[ -n "$body" ]] && echo "$body" | jq . >/dev/null 2>&1; then
                log_fail "  Ответ: $(echo "$body" | jq -c '.error // .')"
            fi
            return 1
        fi
    }

    # http_get — GET запрос с авторизацией
    # Аргументы: $1=base_url, $2=token, $3=path
    http_get() {
        local base_url="$1"
        local token="$2"
        local path="$3"

        local tmpout
        tmpout=$(mktemp)
        local http_code

        local curl_args=($CURL_OPTS -w "%{http_code}" -o "$tmpout")
        if [[ -n "$token" ]]; then
            curl_args+=(-H "Authorization: Bearer ${token}")
        fi

        http_code=$(curl "${curl_args[@]}" "${base_url}${path}") || http_code="000"

        local body
        body=$(cat "$tmpout")
        rm -f "$tmpout"

        echo "${http_code} ${body}"
    }

    # http_post — POST запрос с JSON телом
    # Аргументы: $1=base_url, $2=token, $3=path, $4=json_data
    http_post() {
        local base_url="$1"
        local token="$2"
        local path="$3"
        local data="$4"

        local tmpout
        tmpout=$(mktemp)
        local http_code

        local curl_args=($CURL_OPTS -w "%{http_code}" -o "$tmpout"
            -X POST
            -H "Content-Type: application/json")
        if [[ -n "$token" ]]; then
            curl_args+=(-H "Authorization: Bearer ${token}")
        fi
        if [[ -n "$data" ]]; then
            curl_args+=(-d "$data")
        fi

        http_code=$(curl "${curl_args[@]}" "${base_url}${path}") || http_code="000"

        local body
        body=$(cat "$tmpout")
        rm -f "$tmpout"

        echo "${http_code} ${body}"
    }
---
# ConfigMap со скриптом инициализации данных
apiVersion: v1
kind: ConfigMap
metadata:
  name: se-test-init-data
  namespace: {{ .Values.namespace }}
  labels:
    {{- include "se-test.labels" . | nindent 4 }}
  annotations:
    helm.sh/hook: post-install
    helm.sh/hook-weight: "-10"
    helm.sh/hook-delete-policy: before-hook-creation
data:
  # Скрипт инициализации тестовых данных.
  # Исходник: tests/scripts/init-data.sh
  init-data.sh: |
    #!/usr/bin/env bash
    # ==========================================================================
    # init-data.sh — инициализация тестовых данных для SE тестовой среды
    # ==========================================================================
    set -euo pipefail
    source /scripts/lib.sh

    log_info "========================================================"
    log_info "  SE Test Environment — Инициализация данных"
    log_info "========================================================"
    log_info ""

    # --- Шаг 1: Дождаться готовности JWKS Mock (до 60 секунд) ---
    log_info "[1/8] Ожидание готовности JWKS Mock..."

    JWKS_READY=false
    JWKS_TIMEOUT=60
    JWKS_ELAPSED=0

    while [[ $JWKS_ELAPSED -lt $JWKS_TIMEOUT ]]; do
        HTTP_CODE=$(curl $CURL_OPTS -o /dev/null -w "%{http_code}" \
            "${JWKS_MOCK_URL}/jwks" 2>/dev/null) || HTTP_CODE="000"
        if [[ "$HTTP_CODE" == "200" ]]; then
            JWKS_READY=true
            break
        fi
        sleep 2
        JWKS_ELAPSED=$((JWKS_ELAPSED + 2))
    done

    if [[ "$JWKS_READY" != "true" ]]; then
        log_fail "JWKS Mock не стал доступен за ${JWKS_TIMEOUT} секунд"
        exit 1
    fi
    log_ok "JWKS Mock доступен (${JWKS_ELAPSED}с)"

    # --- Шаг 2: Получить JWT токен ---
    log_info "[2/8] Получение JWT токена..."

    TOKEN=$(get_token "$JWKS_MOCK_URL" "init-job" '["files:read","files:write","storage:write"]' 3600)

    if [[ -z "$TOKEN" || "$TOKEN" == "null" ]]; then
        log_fail "Не удалось получить JWT токен"
        exit 1
    fi
    log_ok "JWT получен (sub=init-job)"

    # --- Шаг 3: Дождаться готовности всех SE (до 120 секунд каждый) ---
    log_info "[3/8] Ожидание готовности Storage Elements..."

    SE_NAMES=("SE_EDIT_1" "SE_EDIT_2" "SE_RW_1" "SE_RW_2" "SE_RO" "SE_AR")
    SE_URLS=("$SE_EDIT_1_URL" "$SE_EDIT_2_URL" "$SE_RW_1_URL" "$SE_RW_2_URL" "$SE_RO_URL" "$SE_AR_URL")
    SE_TIMEOUT=120

    ALL_READY=true
    for i in "${!SE_NAMES[@]}"; do
        NAME="${SE_NAMES[$i]}"
        URL="${SE_URLS[$i]}"
        log_info "  Ожидание ${NAME}..."

        if wait_ready "$URL" $SE_TIMEOUT; then
            log_ok "  ${NAME} готов"
        else
            log_fail "  ${NAME} не стал доступен за ${SE_TIMEOUT} секунд"
            ALL_READY=false
        fi
    done

    if [[ "$ALL_READY" != "true" ]]; then
        log_fail "Не все SE экземпляры готовы — прерывание"
        exit 1
    fi
    log_ok "Все 6 SE экземпляров готовы"

    # --- Шаг 4: Загрузка 4 файлов в se-ro ---
    log_info "[4/8] Загрузка тестовых файлов в se-ro (4 файла)..."

    RO_UPLOADED=0
    RO_FILES=("test-ro-doc.bin" "test-ro-image.bin" "test-ro-data.bin" "test-ro-backup.bin")
    RO_DESCS=("Тестовый документ" "Тестовое изображение" "Тестовые данные" "Тестовый бэкап")

    for i in "${!RO_FILES[@]}"; do
        FILENAME="${RO_FILES[$i]}"
        DESC="${RO_DESCS[$i]}"

        RESPONSE=$(upload_file "$SE_RO_URL" "$TOKEN" "$FILENAME" "application/octet-stream" "$DESC")

        if assert_status "$RESPONSE" 201 "Upload ${FILENAME}"; then
            RO_UPLOADED=$((RO_UPLOADED + 1))
            FILE_ID=$(get_response_body "$RESPONSE" | jq -r '.file_id // .id // "unknown"')
            log_ok "  ${FILENAME} -> ${FILE_ID}"
        else
            log_fail "Не удалось загрузить ${FILENAME} в se-ro"
            exit 1
        fi
    done

    log_ok "Загружено ${RO_UPLOADED} файлов в se-ro"

    # --- Шаг 5: Загрузка 200 файлов в se-ar ---
    log_info "[5/8] Загрузка тестовых файлов в se-ar (200 файлов, ~1KB каждый)..."

    AR_UPLOADED=0
    AR_FAILED=0

    for i in $(seq 1 200); do
        FILENAME="test-ar-$(printf '%03d' "$i").bin"

        RESPONSE=$(upload_file "$SE_AR_URL" "$TOKEN" "$FILENAME" "application/octet-stream" "Архивный файл ${i}/200")

        if assert_status "$RESPONSE" 201 ""; then
            AR_UPLOADED=$((AR_UPLOADED + 1))
        else
            AR_FAILED=$((AR_FAILED + 1))
            log_warn "  Ошибка при загрузке ${FILENAME}"
        fi

        # Прогресс каждые 50 файлов
        if (( i % 50 == 0 )); then
            log_info "  Прогресс: ${i}/200 (загружено: ${AR_UPLOADED}, ошибок: ${AR_FAILED})"
        fi
    done

    if [[ $AR_UPLOADED -ne 200 ]]; then
        log_fail "Загружено ${AR_UPLOADED}/200 файлов в se-ar (${AR_FAILED} ошибок)"
        exit 1
    fi
    log_ok "Загружено ${AR_UPLOADED} файлов в se-ar"

    # --- Шаг 6: Перевод se-ro: rw -> ro ---
    log_info "[6/8] Перевод se-ro в режим ro..."

    RESPONSE=$(transition_mode "$SE_RO_URL" "$TOKEN" "ro" "false")

    if assert_status "$RESPONSE" 200 "Transition se-ro rw->ro"; then
        BODY=$(get_response_body "$RESPONSE")
        PREV=$(echo "$BODY" | jq -r '.previous_mode // "unknown"')
        CURR=$(echo "$BODY" | jq -r '.current_mode // "unknown"')
        log_ok "se-ro: ${PREV} -> ${CURR}"
    else
        log_fail "Не удалось перевести se-ro в режим ro"
        exit 1
    fi

    # --- Шаг 7: Перевод se-ar: rw -> ro -> ar ---
    log_info "[7/8] Перевод se-ar в режим ar (rw -> ro -> ar)..."

    RESPONSE=$(transition_mode "$SE_AR_URL" "$TOKEN" "ro" "false")
    if assert_status "$RESPONSE" 200 "Transition se-ar rw->ro"; then
        BODY=$(get_response_body "$RESPONSE")
        log_ok "se-ar: $(echo "$BODY" | jq -r '.previous_mode') -> $(echo "$BODY" | jq -r '.current_mode')"
    else
        log_fail "Не удалось перевести se-ar в режим ro"
        exit 1
    fi

    RESPONSE=$(transition_mode "$SE_AR_URL" "$TOKEN" "ar" "false")
    if assert_status "$RESPONSE" 200 "Transition se-ar ro->ar"; then
        BODY=$(get_response_body "$RESPONSE")
        log_ok "se-ar: $(echo "$BODY" | jq -r '.previous_mode') -> $(echo "$BODY" | jq -r '.current_mode')"
    else
        log_fail "Не удалось перевести se-ar в режим ar"
        exit 1
    fi

    # --- Шаг 7c: Удаление физических файлов из se-ar (оставляем только attr.json) ---
    log_info "  Удаление физических файлов из se-ar (оставляем только *.attr.json)..."

    if [[ -d "${SE_AR_DATA_DIR:-}" ]]; then
        DELETED_COUNT=$(find "$SE_AR_DATA_DIR" -maxdepth 1 -type f \
            ! -name '*.attr.json' ! -name '.*' -delete -print | wc -l)
        log_ok "  Удалено ${DELETED_COUNT} файлов данных, attr.json сохранены"
    else
        log_warn "  SE_AR_DATA_DIR не смонтирован — пропуск очистки"
    fi

    # --- Шаг 8: Итоговый отчёт ---
    log_info ""
    log_info "========================================================"
    log_info "  Инициализация завершена успешно"
    log_info "========================================================"
    log_ok "se-edit-1 : режим edit, replicated (2 реплики)"
    log_ok "se-edit-2 : режим edit, replicated (2 реплики)"
    log_ok "se-rw-1   : режим rw, standalone"
    log_ok "se-rw-2   : режим rw, standalone"
    log_ok "se-ro     : режим ro, standalone, ${RO_UPLOADED} файлов"
    log_ok "se-ar     : режим ar, standalone, ${AR_UPLOADED} attr.json (только метаданные)"
    log_info "========================================================"
---
# Job (post-install hook) — запускает init-data.sh после деплоя
apiVersion: batch/v1
kind: Job
metadata:
  name: se-test-init
  namespace: {{ .Values.namespace }}
  labels:
    {{- include "se-test.labels" . | nindent 4 }}
  annotations:
    helm.sh/hook: post-install
    helm.sh/hook-weight: "0"
    helm.sh/hook-delete-policy: before-hook-creation
spec:
  activeDeadlineSeconds: {{ .Values.initJob.activeDeadlineSeconds }}
  backoffLimit: 2
  template:
    metadata:
      labels:
        app.kubernetes.io/name: se-test-init
    spec:
      restartPolicy: Never
      containers:
        - name: init
          image: alpine:3.19
          # Установка зависимостей (bash, curl, jq) и запуск скрипта
          command:
            - /bin/sh
            - -c
            - apk add --no-cache bash curl jq && exec /bin/bash /scripts/init-data.sh
          env:
            # URL JWKS Mock для получения JWT
            - name: JWKS_MOCK_URL
              value: "https://jwks-mock.{{ .Values.namespace }}.svc.cluster.local:{{ .Values.jwksMock.port }}"
            # URL всех SE экземпляров
            {{- range .Values.replicatedInstances }}
            - name: {{ .name | upper | replace "-" "_" }}_URL
              value: "https://{{ .name }}.{{ $.Values.namespace }}.svc.cluster.local:{{ $.Values.seCommon.port }}"
            {{- end }}
            {{- range .Values.standaloneInstances }}
            - name: {{ .name | upper | replace "-" "_" }}_URL
              value: "https://{{ .name }}.{{ $.Values.namespace }}.svc.cluster.local:{{ $.Values.seCommon.port }}"
            {{- end }}
            # Опции curl (пропуск проверки TLS для self-signed сертификатов)
            - name: CURL_OPTS
              value: "-k -s --connect-timeout 5"
            # Путь к PVC se-ar для удаления data-файлов (оставляем только attr.json)
            - name: SE_AR_DATA_DIR
              value: /mnt/se-ar-data
          volumeMounts:
            - name: init-lib
              mountPath: /scripts/lib.sh
              subPath: lib.sh
            - name: init-data
              mountPath: /scripts/init-data.sh
              subPath: init-data.sh
            # PVC se-ar — для очистки data-файлов после перехода в ar
            - name: se-ar-data
              mountPath: /mnt/se-ar-data
      volumes:
        - name: init-lib
          configMap:
            name: se-test-init-lib
            defaultMode: 0755
        - name: init-data
          configMap:
            name: se-test-init-data
            defaultMode: 0755
        # PVC se-ar-data (ReadWriteMany, NFS) — для удаления data-файлов
        - name: se-ar-data
          persistentVolumeClaim:
            claimName: se-ar-data
{{- end }}
