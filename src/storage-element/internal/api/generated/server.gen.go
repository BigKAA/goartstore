// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Список файлов
	// (GET /api/v1/files)
	ListFiles(w http.ResponseWriter, r *http.Request, params ListFilesParams)
	// Загрузка файла
	// (POST /api/v1/files/upload)
	UploadFile(w http.ResponseWriter, r *http.Request)
	// Удаление файла
	// (DELETE /api/v1/files/{file_id})
	DeleteFile(w http.ResponseWriter, r *http.Request, fileId FileId)
	// Метаданные файла
	// (GET /api/v1/files/{file_id})
	GetFileMetadata(w http.ResponseWriter, r *http.Request, fileId FileId)
	// Обновление метаданных файла
	// (PATCH /api/v1/files/{file_id})
	UpdateFileMetadata(w http.ResponseWriter, r *http.Request, fileId FileId)
	// Скачивание файла
	// (GET /api/v1/files/{file_id}/download)
	DownloadFile(w http.ResponseWriter, r *http.Request, fileId FileId, params DownloadFileParams)
	// Информация о Storage Element
	// (GET /api/v1/info)
	GetStorageInfo(w http.ResponseWriter, r *http.Request)
	// Ручная сверка (reconciliation)
	// (POST /api/v1/maintenance/reconcile)
	Reconcile(w http.ResponseWriter, r *http.Request)
	// Смена режима работы
	// (POST /api/v1/mode/transition)
	TransitionMode(w http.ResponseWriter, r *http.Request)
	// Liveness probe
	// (GET /health/live)
	HealthLive(w http.ResponseWriter, r *http.Request)
	// Readiness probe
	// (GET /health/ready)
	HealthReady(w http.ResponseWriter, r *http.Request)
	// Prometheus metrics
	// (GET /metrics)
	GetMetrics(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Список файлов
// (GET /api/v1/files)
func (_ Unimplemented) ListFiles(w http.ResponseWriter, r *http.Request, params ListFilesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Загрузка файла
// (POST /api/v1/files/upload)
func (_ Unimplemented) UploadFile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Удаление файла
// (DELETE /api/v1/files/{file_id})
func (_ Unimplemented) DeleteFile(w http.ResponseWriter, r *http.Request, fileId FileId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Метаданные файла
// (GET /api/v1/files/{file_id})
func (_ Unimplemented) GetFileMetadata(w http.ResponseWriter, r *http.Request, fileId FileId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Обновление метаданных файла
// (PATCH /api/v1/files/{file_id})
func (_ Unimplemented) UpdateFileMetadata(w http.ResponseWriter, r *http.Request, fileId FileId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Скачивание файла
// (GET /api/v1/files/{file_id}/download)
func (_ Unimplemented) DownloadFile(w http.ResponseWriter, r *http.Request, fileId FileId, params DownloadFileParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Информация о Storage Element
// (GET /api/v1/info)
func (_ Unimplemented) GetStorageInfo(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Ручная сверка (reconciliation)
// (POST /api/v1/maintenance/reconcile)
func (_ Unimplemented) Reconcile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Смена режима работы
// (POST /api/v1/mode/transition)
func (_ Unimplemented) TransitionMode(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Liveness probe
// (GET /health/live)
func (_ Unimplemented) HealthLive(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Readiness probe
// (GET /health/ready)
func (_ Unimplemented) HealthReady(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Prometheus metrics
// (GET /metrics)
func (_ Unimplemented) GetMetrics(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListFiles operation middleware
func (siw *ServerInterfaceWrapper) ListFiles(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"files:read"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFilesParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListFiles(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UploadFile operation middleware
func (siw *ServerInterfaceWrapper) UploadFile(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"files:write"})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadFile(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteFile operation middleware
func (siw *ServerInterfaceWrapper) DeleteFile(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "file_id" -------------
	var fileId FileId

	err = runtime.BindStyledParameterWithOptions("simple", "file_id", chi.URLParam(r, "file_id"), &fileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "file_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"files:write"})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteFile(w, r, fileId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetFileMetadata operation middleware
func (siw *ServerInterfaceWrapper) GetFileMetadata(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "file_id" -------------
	var fileId FileId

	err = runtime.BindStyledParameterWithOptions("simple", "file_id", chi.URLParam(r, "file_id"), &fileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "file_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"files:read"})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFileMetadata(w, r, fileId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateFileMetadata operation middleware
func (siw *ServerInterfaceWrapper) UpdateFileMetadata(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "file_id" -------------
	var fileId FileId

	err = runtime.BindStyledParameterWithOptions("simple", "file_id", chi.URLParam(r, "file_id"), &fileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "file_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"files:write"})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateFileMetadata(w, r, fileId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DownloadFile operation middleware
func (siw *ServerInterfaceWrapper) DownloadFile(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "file_id" -------------
	var fileId FileId

	err = runtime.BindStyledParameterWithOptions("simple", "file_id", chi.URLParam(r, "file_id"), &fileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "file_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"files:read"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadFileParams

	headers := r.Header

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Range", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Range", valueList[0], &Range, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Range", Err: err})
			return
		}

		params.Range = &Range

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadFile(w, r, fileId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetStorageInfo operation middleware
func (siw *ServerInterfaceWrapper) GetStorageInfo(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStorageInfo(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Reconcile operation middleware
func (siw *ServerInterfaceWrapper) Reconcile(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"storage:write"})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Reconcile(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TransitionMode operation middleware
func (siw *ServerInterfaceWrapper) TransitionMode(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"storage:write"})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TransitionMode(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HealthLive operation middleware
func (siw *ServerInterfaceWrapper) HealthLive(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthLive(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HealthReady operation middleware
func (siw *ServerInterfaceWrapper) HealthReady(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthReady(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetMetrics operation middleware
func (siw *ServerInterfaceWrapper) GetMetrics(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMetrics(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/files", wrapper.ListFiles)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/files/upload", wrapper.UploadFile)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/files/{file_id}", wrapper.DeleteFile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/files/{file_id}", wrapper.GetFileMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/api/v1/files/{file_id}", wrapper.UpdateFileMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/files/{file_id}/download", wrapper.DownloadFile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/info", wrapper.GetStorageInfo)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/maintenance/reconcile", wrapper.Reconcile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/mode/transition", wrapper.TransitionMode)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/health/live", wrapper.HealthLive)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/health/ready", wrapper.HealthReady)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/metrics", wrapper.GetMetrics)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
