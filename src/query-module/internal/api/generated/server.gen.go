// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Метаданные файла
	// (GET /api/v1/files/{file_id})
	GetFileMetadata(w http.ResponseWriter, r *http.Request, fileId FileId)
	// Скачивание файла
	// (GET /api/v1/files/{file_id}/download)
	DownloadFile(w http.ResponseWriter, r *http.Request, fileId FileId, params DownloadFileParams)
	// Поиск файлов
	// (POST /api/v1/search)
	SearchFiles(w http.ResponseWriter, r *http.Request)
	// Liveness probe
	// (GET /health/live)
	HealthLive(w http.ResponseWriter, r *http.Request)
	// Readiness probe
	// (GET /health/ready)
	HealthReady(w http.ResponseWriter, r *http.Request)
	// Prometheus metrics
	// (GET /metrics)
	GetMetrics(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Метаданные файла
// (GET /api/v1/files/{file_id})
func (_ Unimplemented) GetFileMetadata(w http.ResponseWriter, r *http.Request, fileId FileId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Скачивание файла
// (GET /api/v1/files/{file_id}/download)
func (_ Unimplemented) DownloadFile(w http.ResponseWriter, r *http.Request, fileId FileId, params DownloadFileParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Поиск файлов
// (POST /api/v1/search)
func (_ Unimplemented) SearchFiles(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Liveness probe
// (GET /health/live)
func (_ Unimplemented) HealthLive(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Readiness probe
// (GET /health/ready)
func (_ Unimplemented) HealthReady(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Prometheus metrics
// (GET /metrics)
func (_ Unimplemented) GetMetrics(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetFileMetadata operation middleware
func (siw *ServerInterfaceWrapper) GetFileMetadata(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "file_id" -------------
	var fileId FileId

	err = runtime.BindStyledParameterWithOptions("simple", "file_id", chi.URLParam(r, "file_id"), &fileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "file_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"files:read"})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFileMetadata(w, r, fileId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DownloadFile operation middleware
func (siw *ServerInterfaceWrapper) DownloadFile(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "file_id" -------------
	var fileId FileId

	err = runtime.BindStyledParameterWithOptions("simple", "file_id", chi.URLParam(r, "file_id"), &fileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "file_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"files:read"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadFileParams

	headers := r.Header

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Range", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Range", valueList[0], &Range, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Range", Err: err})
			return
		}

		params.Range = &Range

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadFile(w, r, fileId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SearchFiles operation middleware
func (siw *ServerInterfaceWrapper) SearchFiles(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"files:read"})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SearchFiles(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HealthLive operation middleware
func (siw *ServerInterfaceWrapper) HealthLive(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthLive(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HealthReady operation middleware
func (siw *ServerInterfaceWrapper) HealthReady(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthReady(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetMetrics operation middleware
func (siw *ServerInterfaceWrapper) GetMetrics(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMetrics(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/files/{file_id}", wrapper.GetFileMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/files/{file_id}/download", wrapper.DownloadFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/search", wrapper.SearchFiles)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/health/live", wrapper.HealthLive)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/health/ready", wrapper.HealthReady)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/metrics", wrapper.GetMetrics)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
