// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Текущий пользователь
	// (GET /api/v1/admin-auth/me)
	GetCurrentUser(w http.ResponseWriter, r *http.Request)
	// Список пользователей
	// (GET /api/v1/admin-users)
	ListAdminUsers(w http.ResponseWriter, r *http.Request, params ListAdminUsersParams)
	// Удалить локальные дополнения пользователя
	// (DELETE /api/v1/admin-users/{id})
	DeleteAdminUser(w http.ResponseWriter, r *http.Request, id UserId)
	// Получить пользователя
	// (GET /api/v1/admin-users/{id})
	GetAdminUser(w http.ResponseWriter, r *http.Request, id UserId)
	// Обновить локальные дополнения пользователя
	// (PUT /api/v1/admin-users/{id})
	UpdateAdminUser(w http.ResponseWriter, r *http.Request, id UserId)
	// Установить/изменить локальное дополнение роли
	// (POST /api/v1/admin-users/{id}/role-override)
	SetRoleOverride(w http.ResponseWriter, r *http.Request, id UserId)
	// Список файлов
	// (GET /api/v1/files)
	ListFiles(w http.ResponseWriter, r *http.Request, params ListFilesParams)
	// Регистрация файла
	// (POST /api/v1/files)
	RegisterFile(w http.ResponseWriter, r *http.Request)
	// Soft delete файла
	// (DELETE /api/v1/files/{file_id})
	DeleteFile(w http.ResponseWriter, r *http.Request, fileId FileId)
	// Метаданные файла
	// (GET /api/v1/files/{file_id})
	GetFile(w http.ResponseWriter, r *http.Request, fileId FileId)
	// Обновление метаданных файла
	// (PUT /api/v1/files/{file_id})
	UpdateFile(w http.ResponseWriter, r *http.Request, fileId FileId)
	// Статус Identity Provider
	// (GET /api/v1/idp/status)
	GetIdpStatus(w http.ResponseWriter, r *http.Request)
	// Принудительная синхронизация SA
	// (POST /api/v1/idp/sync-sa)
	SyncServiceAccounts(w http.ResponseWriter, r *http.Request)
	// Список сервисных аккаунтов
	// (GET /api/v1/service-accounts)
	ListServiceAccounts(w http.ResponseWriter, r *http.Request, params ListServiceAccountsParams)
	// Создать сервисный аккаунт
	// (POST /api/v1/service-accounts)
	CreateServiceAccount(w http.ResponseWriter, r *http.Request)
	// Удалить сервисный аккаунт
	// (DELETE /api/v1/service-accounts/{id})
	DeleteServiceAccount(w http.ResponseWriter, r *http.Request, id ServiceAccountId)
	// Получить сервисный аккаунт
	// (GET /api/v1/service-accounts/{id})
	GetServiceAccount(w http.ResponseWriter, r *http.Request, id ServiceAccountId)
	// Обновить сервисный аккаунт
	// (PUT /api/v1/service-accounts/{id})
	UpdateServiceAccount(w http.ResponseWriter, r *http.Request, id ServiceAccountId)
	// Ротация secret
	// (POST /api/v1/service-accounts/{id}/rotate-secret)
	RotateSecret(w http.ResponseWriter, r *http.Request, id ServiceAccountId)
	// Список Storage Elements
	// (GET /api/v1/storage-elements)
	ListStorageElements(w http.ResponseWriter, r *http.Request, params ListStorageElementsParams)
	// Регистрация Storage Element
	// (POST /api/v1/storage-elements)
	CreateStorageElement(w http.ResponseWriter, r *http.Request)
	// Предпросмотр Storage Element
	// (POST /api/v1/storage-elements/discover)
	DiscoverStorageElement(w http.ResponseWriter, r *http.Request)
	// Удалить Storage Element
	// (DELETE /api/v1/storage-elements/{id})
	DeleteStorageElement(w http.ResponseWriter, r *http.Request, id StorageElementId)
	// Получить Storage Element
	// (GET /api/v1/storage-elements/{id})
	GetStorageElement(w http.ResponseWriter, r *http.Request, id StorageElementId)
	// Обновить Storage Element
	// (PUT /api/v1/storage-elements/{id})
	UpdateStorageElement(w http.ResponseWriter, r *http.Request, id StorageElementId)
	// Синхронизация Storage Element
	// (POST /api/v1/storage-elements/{id}/sync)
	SyncStorageElement(w http.ResponseWriter, r *http.Request, id StorageElementId)
	// Liveness probe
	// (GET /health/live)
	HealthLive(w http.ResponseWriter, r *http.Request)
	// Readiness probe
	// (GET /health/ready)
	HealthReady(w http.ResponseWriter, r *http.Request)
	// Prometheus metrics
	// (GET /metrics)
	GetMetrics(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Текущий пользователь
// (GET /api/v1/admin-auth/me)
func (_ Unimplemented) GetCurrentUser(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Список пользователей
// (GET /api/v1/admin-users)
func (_ Unimplemented) ListAdminUsers(w http.ResponseWriter, r *http.Request, params ListAdminUsersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Удалить локальные дополнения пользователя
// (DELETE /api/v1/admin-users/{id})
func (_ Unimplemented) DeleteAdminUser(w http.ResponseWriter, r *http.Request, id UserId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить пользователя
// (GET /api/v1/admin-users/{id})
func (_ Unimplemented) GetAdminUser(w http.ResponseWriter, r *http.Request, id UserId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Обновить локальные дополнения пользователя
// (PUT /api/v1/admin-users/{id})
func (_ Unimplemented) UpdateAdminUser(w http.ResponseWriter, r *http.Request, id UserId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Установить/изменить локальное дополнение роли
// (POST /api/v1/admin-users/{id}/role-override)
func (_ Unimplemented) SetRoleOverride(w http.ResponseWriter, r *http.Request, id UserId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Список файлов
// (GET /api/v1/files)
func (_ Unimplemented) ListFiles(w http.ResponseWriter, r *http.Request, params ListFilesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Регистрация файла
// (POST /api/v1/files)
func (_ Unimplemented) RegisterFile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Soft delete файла
// (DELETE /api/v1/files/{file_id})
func (_ Unimplemented) DeleteFile(w http.ResponseWriter, r *http.Request, fileId FileId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Метаданные файла
// (GET /api/v1/files/{file_id})
func (_ Unimplemented) GetFile(w http.ResponseWriter, r *http.Request, fileId FileId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Обновление метаданных файла
// (PUT /api/v1/files/{file_id})
func (_ Unimplemented) UpdateFile(w http.ResponseWriter, r *http.Request, fileId FileId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Статус Identity Provider
// (GET /api/v1/idp/status)
func (_ Unimplemented) GetIdpStatus(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Принудительная синхронизация SA
// (POST /api/v1/idp/sync-sa)
func (_ Unimplemented) SyncServiceAccounts(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Список сервисных аккаунтов
// (GET /api/v1/service-accounts)
func (_ Unimplemented) ListServiceAccounts(w http.ResponseWriter, r *http.Request, params ListServiceAccountsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Создать сервисный аккаунт
// (POST /api/v1/service-accounts)
func (_ Unimplemented) CreateServiceAccount(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Удалить сервисный аккаунт
// (DELETE /api/v1/service-accounts/{id})
func (_ Unimplemented) DeleteServiceAccount(w http.ResponseWriter, r *http.Request, id ServiceAccountId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить сервисный аккаунт
// (GET /api/v1/service-accounts/{id})
func (_ Unimplemented) GetServiceAccount(w http.ResponseWriter, r *http.Request, id ServiceAccountId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Обновить сервисный аккаунт
// (PUT /api/v1/service-accounts/{id})
func (_ Unimplemented) UpdateServiceAccount(w http.ResponseWriter, r *http.Request, id ServiceAccountId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Ротация secret
// (POST /api/v1/service-accounts/{id}/rotate-secret)
func (_ Unimplemented) RotateSecret(w http.ResponseWriter, r *http.Request, id ServiceAccountId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Список Storage Elements
// (GET /api/v1/storage-elements)
func (_ Unimplemented) ListStorageElements(w http.ResponseWriter, r *http.Request, params ListStorageElementsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Регистрация Storage Element
// (POST /api/v1/storage-elements)
func (_ Unimplemented) CreateStorageElement(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Предпросмотр Storage Element
// (POST /api/v1/storage-elements/discover)
func (_ Unimplemented) DiscoverStorageElement(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Удалить Storage Element
// (DELETE /api/v1/storage-elements/{id})
func (_ Unimplemented) DeleteStorageElement(w http.ResponseWriter, r *http.Request, id StorageElementId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Получить Storage Element
// (GET /api/v1/storage-elements/{id})
func (_ Unimplemented) GetStorageElement(w http.ResponseWriter, r *http.Request, id StorageElementId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Обновить Storage Element
// (PUT /api/v1/storage-elements/{id})
func (_ Unimplemented) UpdateStorageElement(w http.ResponseWriter, r *http.Request, id StorageElementId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Синхронизация Storage Element
// (POST /api/v1/storage-elements/{id}/sync)
func (_ Unimplemented) SyncStorageElement(w http.ResponseWriter, r *http.Request, id StorageElementId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Liveness probe
// (GET /health/live)
func (_ Unimplemented) HealthLive(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Readiness probe
// (GET /health/ready)
func (_ Unimplemented) HealthReady(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Prometheus metrics
// (GET /metrics)
func (_ Unimplemented) GetMetrics(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetCurrentUser operation middleware
func (siw *ServerInterfaceWrapper) GetCurrentUser(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCurrentUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListAdminUsers operation middleware
func (siw *ServerInterfaceWrapper) ListAdminUsers(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAdminUsersParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListAdminUsers(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteAdminUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteAdminUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id UserId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteAdminUser(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAdminUser operation middleware
func (siw *ServerInterfaceWrapper) GetAdminUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id UserId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAdminUser(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateAdminUser operation middleware
func (siw *ServerInterfaceWrapper) UpdateAdminUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id UserId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateAdminUser(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SetRoleOverride operation middleware
func (siw *ServerInterfaceWrapper) SetRoleOverride(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id UserId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetRoleOverride(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListFiles operation middleware
func (siw *ServerInterfaceWrapper) ListFiles(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"files:read"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFilesParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "retention_policy" -------------

	err = runtime.BindQueryParameter("form", true, false, "retention_policy", r.URL.Query(), &params.RetentionPolicy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "retention_policy", Err: err})
		return
	}

	// ------------- Optional query parameter "storage_element_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "storage_element_id", r.URL.Query(), &params.StorageElementId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "storage_element_id", Err: err})
		return
	}

	// ------------- Optional query parameter "uploaded_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "uploaded_by", r.URL.Query(), &params.UploadedBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uploaded_by", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListFiles(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RegisterFile operation middleware
func (siw *ServerInterfaceWrapper) RegisterFile(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"files:write"})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RegisterFile(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteFile operation middleware
func (siw *ServerInterfaceWrapper) DeleteFile(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "file_id" -------------
	var fileId FileId

	err = runtime.BindStyledParameterWithOptions("simple", "file_id", chi.URLParam(r, "file_id"), &fileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "file_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"files:write"})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteFile(w, r, fileId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetFile operation middleware
func (siw *ServerInterfaceWrapper) GetFile(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "file_id" -------------
	var fileId FileId

	err = runtime.BindStyledParameterWithOptions("simple", "file_id", chi.URLParam(r, "file_id"), &fileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "file_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"files:read"})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFile(w, r, fileId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateFile operation middleware
func (siw *ServerInterfaceWrapper) UpdateFile(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "file_id" -------------
	var fileId FileId

	err = runtime.BindStyledParameterWithOptions("simple", "file_id", chi.URLParam(r, "file_id"), &fileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "file_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"files:write"})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateFile(w, r, fileId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetIdpStatus operation middleware
func (siw *ServerInterfaceWrapper) GetIdpStatus(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetIdpStatus(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SyncServiceAccounts operation middleware
func (siw *ServerInterfaceWrapper) SyncServiceAccounts(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SyncServiceAccounts(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListServiceAccounts operation middleware
func (siw *ServerInterfaceWrapper) ListServiceAccounts(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListServiceAccountsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListServiceAccounts(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateServiceAccount operation middleware
func (siw *ServerInterfaceWrapper) CreateServiceAccount(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateServiceAccount(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteServiceAccount operation middleware
func (siw *ServerInterfaceWrapper) DeleteServiceAccount(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id ServiceAccountId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteServiceAccount(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetServiceAccount operation middleware
func (siw *ServerInterfaceWrapper) GetServiceAccount(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id ServiceAccountId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetServiceAccount(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateServiceAccount operation middleware
func (siw *ServerInterfaceWrapper) UpdateServiceAccount(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id ServiceAccountId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateServiceAccount(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RotateSecret operation middleware
func (siw *ServerInterfaceWrapper) RotateSecret(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id ServiceAccountId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RotateSecret(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListStorageElements operation middleware
func (siw *ServerInterfaceWrapper) ListStorageElements(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"storage:read"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListStorageElementsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, false, "mode", r.URL.Query(), &params.Mode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mode", Err: err})
		return
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListStorageElements(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateStorageElement operation middleware
func (siw *ServerInterfaceWrapper) CreateStorageElement(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateStorageElement(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DiscoverStorageElement operation middleware
func (siw *ServerInterfaceWrapper) DiscoverStorageElement(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DiscoverStorageElement(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteStorageElement operation middleware
func (siw *ServerInterfaceWrapper) DeleteStorageElement(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id StorageElementId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteStorageElement(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetStorageElement operation middleware
func (siw *ServerInterfaceWrapper) GetStorageElement(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id StorageElementId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"storage:read"})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStorageElement(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateStorageElement operation middleware
func (siw *ServerInterfaceWrapper) UpdateStorageElement(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id StorageElementId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateStorageElement(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SyncStorageElement operation middleware
func (siw *ServerInterfaceWrapper) SyncStorageElement(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id StorageElementId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"storage:write"})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SyncStorageElement(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HealthLive operation middleware
func (siw *ServerInterfaceWrapper) HealthLive(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthLive(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HealthReady operation middleware
func (siw *ServerInterfaceWrapper) HealthReady(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthReady(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetMetrics operation middleware
func (siw *ServerInterfaceWrapper) GetMetrics(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMetrics(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin-auth/me", wrapper.GetCurrentUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin-users", wrapper.ListAdminUsers)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/admin-users/{id}", wrapper.DeleteAdminUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin-users/{id}", wrapper.GetAdminUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/admin-users/{id}", wrapper.UpdateAdminUser)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin-users/{id}/role-override", wrapper.SetRoleOverride)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/files", wrapper.ListFiles)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/files", wrapper.RegisterFile)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/files/{file_id}", wrapper.DeleteFile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/files/{file_id}", wrapper.GetFile)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/files/{file_id}", wrapper.UpdateFile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/idp/status", wrapper.GetIdpStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/idp/sync-sa", wrapper.SyncServiceAccounts)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/service-accounts", wrapper.ListServiceAccounts)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/service-accounts", wrapper.CreateServiceAccount)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/service-accounts/{id}", wrapper.DeleteServiceAccount)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/service-accounts/{id}", wrapper.GetServiceAccount)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/service-accounts/{id}", wrapper.UpdateServiceAccount)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/service-accounts/{id}/rotate-secret", wrapper.RotateSecret)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/storage-elements", wrapper.ListStorageElements)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/storage-elements", wrapper.CreateStorageElement)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/storage-elements/discover", wrapper.DiscoverStorageElement)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/storage-elements/{id}", wrapper.DeleteStorageElement)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/storage-elements/{id}", wrapper.GetStorageElement)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/storage-elements/{id}", wrapper.UpdateStorageElement)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/storage-elements/{id}/sync", wrapper.SyncStorageElement)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/health/live", wrapper.HealthLive)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/health/ready", wrapper.HealthReady)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/metrics", wrapper.GetMetrics)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//KLbsUWvNAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
