# =============================================================================
# Init Job — standalone manifest для инициализации тестовых данных.
#
# Получает токен из Keycloak (Client Credentials), ждёт готовности AM и SE,
# загружает файлы в SE, переводит se-ro и se-ar в нужные режимы.
#
# Запуск: make init-data (envsubst подставит переменные)
# Перезапуск: make init-data-clean && make init-data
#
# Переменные (из Makefile через envsubst):
#   NAMESPACE, INFRA_RELEASE, SE_PORT, AM_PORT
# =============================================================================
---
# ConfigMap с общей библиотекой функций (lib.sh)
apiVersion: v1
kind: ConfigMap
metadata:
  name: artsore-init-lib
  namespace: ${NAMESPACE}
data:
  lib.sh: |
    #!/usr/bin/env bash
    # ==========================================================================
    # lib.sh — общая библиотека функций для Artsore тестовых скриптов
    # ==========================================================================
    set -euo pipefail

    : "${CURL_OPTS:=-k -s --connect-timeout 5}"

    # ---- Логирование ----
    log_info() { echo -e "\033[0;34m[INFO]\033[0m  $*"; }
    log_ok()   { echo -e "\033[0;32m[OK]\033[0m    $*"; }
    log_fail() { echo -e "\033[0;31m[FAIL]\033[0m  $*"; }
    log_warn() { echo -e "\033[0;33m[WARN]\033[0m  $*"; }

    # ---- Счётчики тестов ----
    PASS_COUNT=0
    FAIL_COUNT=0
    test_pass() { ((PASS_COUNT++)); log_ok "PASS: $*"; }
    test_fail() { ((FAIL_COUNT++)); log_fail "FAIL: $*"; }
    print_summary() {
        local total=$((PASS_COUNT + FAIL_COUNT))
        echo ""
        log_info "========================================================"
        log_info "Результаты: ${PASS_COUNT} PASS / ${FAIL_COUNT} FAIL (всего ${total})"
        log_info "========================================================"
        [[ $FAIL_COUNT -gt 0 ]] && return 1 || return 0
    }

    # ---- Утилиты для работы с ответами ----
    get_response_code() { echo "$1" | awk '{print $1}'; }
    get_response_body() { echo "$1" | cut -d' ' -f2-; }

    # ---- Основные функции ----

    get_token_from_keycloak() {
        local endpoint="$1" client_id="$2" client_secret="$3"
        local tmpout; tmpout=$(mktemp)
        local http_code
        http_code=$(curl $CURL_OPTS -w "%{http_code}" -o "$tmpout" \
            -X POST -d "grant_type=client_credentials" \
            -d "client_id=${client_id}" -d "client_secret=${client_secret}" \
            "${endpoint}") || true
        local body; body=$(cat "$tmpout"); rm -f "$tmpout"
        if [[ "$http_code" != "200" ]]; then
            log_fail "get_token_from_keycloak: HTTP ${http_code} от ${endpoint}"
            echo "$body" | jq . >/dev/null 2>&1 && log_fail "  Ответ: $(echo "$body" | jq -c '.')"
            echo ""; return 1
        fi
        echo "$body" | jq -r '.access_token'
    }

    wait_ready() {
        local url="$1" timeout="${2:-120}" elapsed=0 interval=2
        while [[ $elapsed -lt $timeout ]]; do
            local http_code
            http_code=$(curl $CURL_OPTS -o /dev/null -w "%{http_code}" \
                "${url}/health/ready" 2>/dev/null) || http_code="000"
            [[ "$http_code" == "200" ]] && return 0
            sleep $interval; elapsed=$((elapsed + interval))
        done
        return 1
    }

    upload_file() {
        local se_url="$1" token="$2" filename="$3"
        local content_type="${4:-application/octet-stream}" description="${5:-}" file_path="${6:-}"
        local tmp_generated=""
        if [[ -z "$file_path" ]]; then
            file_path=$(mktemp); dd if=/dev/urandom bs=1024 count=1 2>/dev/null > "$file_path"
            tmp_generated="$file_path"
        fi
        local tmpout; tmpout=$(mktemp)
        local curl_args=($CURL_OPTS -w "%{http_code}" -o "$tmpout" -X POST \
            -H "Authorization: Bearer ${token}" \
            -F "file=@${file_path};filename=${filename};type=${content_type}")
        [[ -n "$description" ]] && curl_args+=(-F "description=${description}")
        local http_code
        http_code=$(curl "${curl_args[@]}" "${se_url}/api/v1/files/upload") || http_code="000"
        local body; body=$(cat "$tmpout"); rm -f "$tmpout"
        [[ -n "$tmp_generated" ]] && rm -f "$tmp_generated"
        echo "${http_code} ${body}"
    }

    transition_mode() {
        local se_url="$1" token="$2" target_mode="$3" confirm="${4:-false}"
        local request_body
        request_body=$(jq -n --arg mode "$target_mode" --argjson confirm "$confirm" \
            '{target_mode: $mode, confirm: $confirm}')
        local tmpout; tmpout=$(mktemp)
        local http_code
        http_code=$(curl $CURL_OPTS -w "%{http_code}" -o "$tmpout" -X POST \
            -H "Authorization: Bearer ${token}" -H "Content-Type: application/json" \
            -d "$request_body" "${se_url}/api/v1/mode/transition") || http_code="000"
        local body; body=$(cat "$tmpout"); rm -f "$tmpout"
        echo "${http_code} ${body}"
    }

    assert_status() {
        local response="$1" expected="$2" message="${3:-}"
        local actual; actual=$(get_response_code "$response")
        if [[ "$actual" == "$expected" ]]; then return 0; fi
        [[ -n "$message" ]] && log_fail "${message}: ожидался HTTP ${expected}, получен ${actual}"
        local body; body=$(get_response_body "$response")
        [[ -n "$body" ]] && echo "$body" | jq . >/dev/null 2>&1 && \
            log_fail "  Ответ: $(echo "$body" | jq -c '.error // .')"
        return 1
    }

    http_get() {
        local base_url="$1" token="$2" path="$3"
        local tmpout; tmpout=$(mktemp)
        local curl_args=($CURL_OPTS -w "%{http_code}" -o "$tmpout")
        [[ -n "$token" ]] && curl_args+=(-H "Authorization: Bearer ${token}")
        local http_code
        http_code=$(curl "${curl_args[@]}" "${base_url}${path}") || http_code="000"
        local body; body=$(cat "$tmpout"); rm -f "$tmpout"
        echo "${http_code} ${body}"
    }

    http_post() {
        local base_url="$1" token="$2" path="$3" data="$4"
        local tmpout; tmpout=$(mktemp)
        local curl_args=($CURL_OPTS -w "%{http_code}" -o "$tmpout" -X POST \
            -H "Content-Type: application/json")
        [[ -n "$token" ]] && curl_args+=(-H "Authorization: Bearer ${token}")
        [[ -n "$data" ]] && curl_args+=(-d "$data")
        local http_code
        http_code=$(curl "${curl_args[@]}" "${base_url}${path}") || http_code="000"
        local body; body=$(cat "$tmpout"); rm -f "$tmpout"
        echo "${http_code} ${body}"
    }

    http_patch() {
        local base_url="$1" token="$2" path="$3" data="$4"
        local tmpout; tmpout=$(mktemp)
        local curl_args=($CURL_OPTS -w "%{http_code}" -o "$tmpout" -X PATCH \
            -H "Content-Type: application/json")
        [[ -n "$token" ]] && curl_args+=(-H "Authorization: Bearer ${token}")
        [[ -n "$data" ]] && curl_args+=(-d "$data")
        local http_code
        http_code=$(curl "${curl_args[@]}" "${base_url}${path}") || http_code="000"
        local body; body=$(cat "$tmpout"); rm -f "$tmpout"
        echo "${http_code} ${body}"
    }

    http_delete() {
        local base_url="$1" token="$2" path="$3"
        local tmpout; tmpout=$(mktemp)
        local curl_args=($CURL_OPTS -w "%{http_code}" -o "$tmpout" -X DELETE)
        [[ -n "$token" ]] && curl_args+=(-H "Authorization: Bearer ${token}")
        local http_code
        http_code=$(curl "${curl_args[@]}" "${base_url}${path}") || http_code="000"
        local body; body=$(cat "$tmpout"); rm -f "$tmpout"
        echo "${http_code} ${body}"
    }
---
# ConfigMap со скриптом инициализации данных
apiVersion: v1
kind: ConfigMap
metadata:
  name: artsore-init-data
  namespace: ${NAMESPACE}
data:
  init-data.sh: |
    #!/usr/bin/env bash
    # ==========================================================================
    # init-data.sh — инициализация тестовых данных для Artsore тестовой среды
    # ==========================================================================
    set -euo pipefail
    source /scripts/lib.sh

    log_info "========================================================"
    log_info "  Artsore Test Environment — Инициализация данных"
    log_info "========================================================"
    log_info ""

    # --- Шаг 1: Дождаться готовности Keycloak ---
    log_info "[1/9] Ожидание готовности Keycloak..."
    KC_READY=false
    KC_TIMEOUT=120
    KC_ELAPSED=0
    while [[ $KC_ELAPSED -lt $KC_TIMEOUT ]]; do
        HTTP_CODE=$(curl $CURL_OPTS -o /dev/null -w "%{http_code}" \
            "${KC_TOKEN_ENDPOINT}" 2>/dev/null) || HTTP_CODE="000"
        if [[ "$HTTP_CODE" == "400" || "$HTTP_CODE" == "401" || "$HTTP_CODE" == "200" || "$HTTP_CODE" == "405" ]]; then
            KC_READY=true; break
        fi
        sleep 3; KC_ELAPSED=$((KC_ELAPSED + 3))
    done
    if [[ "$KC_READY" != "true" ]]; then
        log_fail "Keycloak не стал доступен за ${KC_TIMEOUT} секунд"; exit 1
    fi
    log_ok "Keycloak доступен (${KC_ELAPSED}с)"

    # --- Шаг 2: Получить JWT токен ---
    log_info "[2/9] Получение JWT токена из Keycloak (Client Credentials)..."
    TOKEN=$(get_token_from_keycloak "$KC_TOKEN_ENDPOINT" "$KC_CLIENT_ID" "$KC_CLIENT_SECRET")
    if [[ -z "$TOKEN" || "$TOKEN" == "null" ]]; then
        log_fail "Не удалось получить JWT токен из Keycloak"; exit 1
    fi
    log_ok "JWT получен (client_id=${KC_CLIENT_ID})"

    # --- Шаг 3: Дождаться готовности Admin Module ---
    log_info "[3/9] Ожидание готовности Admin Module..."
    if wait_ready "$AM_URL" 120; then
        log_ok "Admin Module готов"
    else
        log_fail "Admin Module не стал доступен за 120 секунд"; exit 1
    fi

    # --- Шаг 4: Дождаться готовности всех SE ---
    log_info "[4/9] Ожидание готовности Storage Elements..."
    SE_NAMES=("SE_EDIT_1" "SE_EDIT_2" "SE_RW_1" "SE_RW_2" "SE_RO" "SE_AR")
    SE_URLS=("$SE_EDIT_1_URL" "$SE_EDIT_2_URL" "$SE_RW_1_URL" "$SE_RW_2_URL" "$SE_RO_URL" "$SE_AR_URL")
    SE_TIMEOUT=120
    ALL_READY=true
    for i in "${!SE_NAMES[@]}"; do
        NAME="${SE_NAMES[$i]}"; URL="${SE_URLS[$i]}"
        log_info "  Ожидание ${NAME}..."
        if wait_ready "$URL" $SE_TIMEOUT; then
            log_ok "  ${NAME} готов"
        else
            log_fail "  ${NAME} не стал доступен за ${SE_TIMEOUT} секунд"; ALL_READY=false
        fi
    done
    if [[ "$ALL_READY" != "true" ]]; then
        log_fail "Не все SE экземпляры готовы — прерывание"; exit 1
    fi
    log_ok "Все 6 SE экземпляров готовы"

    # --- Шаг 5: Загрузка 4 файлов в se-ro ---
    log_info "[5/9] Загрузка тестовых файлов в se-ro (4 файла)..."
    RO_UPLOADED=0
    RO_FILES=("test-ro-doc.bin" "test-ro-image.bin" "test-ro-data.bin" "test-ro-backup.bin")
    RO_DESCS=("Тестовый документ" "Тестовое изображение" "Тестовые данные" "Тестовый бэкап")
    for i in "${!RO_FILES[@]}"; do
        FILENAME="${RO_FILES[$i]}"; DESC="${RO_DESCS[$i]}"
        RESPONSE=$(upload_file "$SE_RO_URL" "$TOKEN" "$FILENAME" "application/octet-stream" "$DESC")
        if assert_status "$RESPONSE" 201 "Upload ${FILENAME}"; then
            RO_UPLOADED=$((RO_UPLOADED + 1))
            FILE_ID=$(get_response_body "$RESPONSE" | jq -r '.file_id // .id // "unknown"')
            log_ok "  ${FILENAME} -> ${FILE_ID}"
        else
            log_fail "Не удалось загрузить ${FILENAME} в se-ro"; exit 1
        fi
    done
    log_ok "Загружено ${RO_UPLOADED} файлов в se-ro"

    # --- Шаг 6: Загрузка 200 файлов в se-ar ---
    log_info "[6/9] Загрузка тестовых файлов в se-ar (200 файлов, ~1KB каждый)..."
    AR_UPLOADED=0; AR_FAILED=0
    for i in $(seq 1 200); do
        FILENAME="test-ar-$(printf '%03d' "$i").bin"
        RESPONSE=$(upload_file "$SE_AR_URL" "$TOKEN" "$FILENAME" "application/octet-stream" "Архивный файл ${i}/200")
        if assert_status "$RESPONSE" 201 ""; then
            AR_UPLOADED=$((AR_UPLOADED + 1))
        else
            AR_FAILED=$((AR_FAILED + 1)); log_warn "  Ошибка при загрузке ${FILENAME}"
        fi
        (( i % 50 == 0 )) && log_info "  Прогресс: ${i}/200 (загружено: ${AR_UPLOADED}, ошибок: ${AR_FAILED})"
    done
    if [[ $AR_UPLOADED -ne 200 ]]; then
        log_fail "Загружено ${AR_UPLOADED}/200 файлов в se-ar (${AR_FAILED} ошибок)"; exit 1
    fi
    log_ok "Загружено ${AR_UPLOADED} файлов в se-ar"

    # --- Шаг 7: Перевод se-ro: rw -> ro ---
    log_info "[7/9] Перевод se-ro в режим ro..."
    RESPONSE=$(transition_mode "$SE_RO_URL" "$TOKEN" "ro" "false")
    if assert_status "$RESPONSE" 200 "Transition se-ro rw->ro"; then
        BODY=$(get_response_body "$RESPONSE")
        log_ok "se-ro: $(echo "$BODY" | jq -r '.previous_mode') -> $(echo "$BODY" | jq -r '.current_mode')"
    else
        log_fail "Не удалось перевести se-ro в режим ro"; exit 1
    fi

    # --- Шаг 8: Перевод se-ar: rw -> ro -> ar ---
    log_info "[8/9] Перевод se-ar в режим ar (rw -> ro -> ar)..."
    RESPONSE=$(transition_mode "$SE_AR_URL" "$TOKEN" "ro" "false")
    if assert_status "$RESPONSE" 200 "Transition se-ar rw->ro"; then
        BODY=$(get_response_body "$RESPONSE")
        log_ok "se-ar: $(echo "$BODY" | jq -r '.previous_mode') -> $(echo "$BODY" | jq -r '.current_mode')"
    else
        log_fail "Не удалось перевести se-ar в режим ro"; exit 1
    fi
    RESPONSE=$(transition_mode "$SE_AR_URL" "$TOKEN" "ar" "false")
    if assert_status "$RESPONSE" 200 "Transition se-ar ro->ar"; then
        BODY=$(get_response_body "$RESPONSE")
        log_ok "se-ar: $(echo "$BODY" | jq -r '.previous_mode') -> $(echo "$BODY" | jq -r '.current_mode')"
    else
        log_fail "Не удалось перевести se-ar в режим ar"; exit 1
    fi

    # Удаление физических файлов из se-ar
    log_info "  Удаление физических файлов из se-ar (оставляем только *.attr.json)..."
    if [[ -d "${SE_AR_DATA_DIR:-}" ]]; then
        DELETED_COUNT=$(find "$SE_AR_DATA_DIR" -maxdepth 1 -type f \
            ! -name '*.attr.json' ! -name '.*' -delete -print | wc -l)
        log_ok "  Удалено ${DELETED_COUNT} файлов данных, attr.json сохранены"
    else
        log_warn "  SE_AR_DATA_DIR не смонтирован — пропуск очистки"
    fi

    # --- Шаг 9: Итоговый отчёт ---
    log_info ""
    log_info "========================================================"
    log_info "  Инициализация завершена успешно"
    log_info "========================================================"
    log_ok "se-edit-1 : режим edit, replicated (2 реплики)"
    log_ok "se-edit-2 : режим edit, replicated (2 реплики)"
    log_ok "se-rw-1   : режим rw, standalone"
    log_ok "se-rw-2   : режим rw, standalone"
    log_ok "se-ro     : режим ro, standalone, ${RO_UPLOADED} файлов"
    log_ok "se-ar     : режим ar, standalone, ${AR_UPLOADED} attr.json (только метаданные)"
    log_ok "AM        : Admin Module работает"
    log_ok "KC        : Keycloak realm artsore импортирован"
    log_ok "PG        : PostgreSQL с БД artsore + keycloak"
    log_info "========================================================"
---
# Job — запускает init-data.sh
apiVersion: batch/v1
kind: Job
metadata:
  name: artsore-init
  namespace: ${NAMESPACE}
spec:
  activeDeadlineSeconds: 600
  backoffLimit: 2
  template:
    metadata:
      labels:
        app.kubernetes.io/name: artsore-init
        app.kubernetes.io/part-of: artsore
    spec:
      restartPolicy: Never
      containers:
        - name: init
          image: harbor.kryukov.lan/library/artsore-tools:latest
          command:
            - /bin/bash
            - /scripts/init-data.sh
          env:
            # Keycloak token endpoint (HTTP — через infraReleaseName)
            - name: KC_TOKEN_ENDPOINT
              value: "http://${INFRA_RELEASE}-keycloak.${NAMESPACE}.svc.cluster.local:8080/realms/artsore/protocol/openid-connect/token"
            # Client Credentials для получения токена
            - name: KC_CLIENT_ID
              value: artsore-test-init
            - name: KC_CLIENT_SECRET
              value: test-init-secret
            # Admin Module URL (HTTP — AM без TLS, termination на Gateway)
            - name: AM_URL
              value: "http://admin-module.${NAMESPACE}.svc.cluster.local:${AM_PORT}"
            # SE URLs
            - name: SE_EDIT_1_URL
              value: "https://se-edit-1.${NAMESPACE}.svc.cluster.local:${SE_PORT}"
            - name: SE_EDIT_2_URL
              value: "https://se-edit-2.${NAMESPACE}.svc.cluster.local:${SE_PORT}"
            - name: SE_RW_1_URL
              value: "https://se-rw-1.${NAMESPACE}.svc.cluster.local:${SE_PORT}"
            - name: SE_RW_2_URL
              value: "https://se-rw-2.${NAMESPACE}.svc.cluster.local:${SE_PORT}"
            - name: SE_RO_URL
              value: "https://se-ro.${NAMESPACE}.svc.cluster.local:${SE_PORT}"
            - name: SE_AR_URL
              value: "https://se-ar.${NAMESPACE}.svc.cluster.local:${SE_PORT}"
            - name: CURL_OPTS
              value: "-k -s --connect-timeout 5"
            # Путь к PVC se-ar для удаления data-файлов
            - name: SE_AR_DATA_DIR
              value: /mnt/se-ar-data
          volumeMounts:
            - name: init-lib
              mountPath: /scripts/lib.sh
              subPath: lib.sh
            - name: init-data
              mountPath: /scripts/init-data.sh
              subPath: init-data.sh
            - name: se-ar-data
              mountPath: /mnt/se-ar-data
      volumes:
        - name: init-lib
          configMap:
            name: artsore-init-lib
            defaultMode: 0755
        - name: init-data
          configMap:
            name: artsore-init-data
            defaultMode: 0755
        - name: se-ar-data
          persistentVolumeClaim:
            claimName: se-ar-data
